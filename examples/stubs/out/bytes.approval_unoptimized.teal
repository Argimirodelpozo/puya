#pragma version 8

// examples.stubs.bytes.BytesContract.approval_program() -> uint64:
main_block@0:
        byte base64 QmFzZSA2NCBlbmNvZGVk
        dup
        byte "Base 64 encoded"
        ==
        assert
        byte base32 IJQXGZJAGMZCAZLOMNXWIZLE
        byte "Base 32 encoded"
        ==
        assert
        byte 0x4261736520313620656e636f646564
        byte "Base 16 encoded"
        ==
        assert
        byte ""
        uncover 1
        len
        assert
        len
        !
        assert
        byte "a"
        byte "b"
        concat
        byte "ab"
        ==
        assert
        byte "c"
        byte "d"
        concat
        byte "cd"
        ==
        assert
        byte "abc"
        dup
        extract 0 1
        byte "a"
        ==
        assert
        dup
        extract 1 0
        byte "bc"
        ==
        assert
        dup
        substring 1 1
        byte ""
        ==
        assert
        dup
        extract 0 1
        byte "a"
        ==
        assert
        dup
        len
        pop
        dup
        len
        int 1
        -
        dig 1
        int 0
        uncover 2
        substring3
        byte "ab"
        ==
        assert
        dup
        len
        cover 1
        dup
        len
        int 2
        -
        dig 1
        uncover 1
        uncover 3
        substring3
        byte "bc"
        ==
        assert
        dup
        len
        pop
        dup
        len
        int 2
        -
        cover 1
        dup
        len
        int 1
        -
        uncover 1
        cover 2
        substring3
        byte "b"
        ==
        assert
        byte "1234567"
        len
        pop
        byte "1234567"
        len
        int 1
        -
        byte "1234567"
        int 1
        uncover 2
        substring3
        byte "23456"
        ==
        assert
        byte "1"
        dup
        cover 1
        byte ""
        cover 1
        len
        bnz main_ternary_false@2

main_ternary_true@1:
        dig 1
        b main_ternary_merge@3

main_ternary_false@2:
        dig 1

main_ternary_merge@3:
        dig 2
        dup
        cover 2
        ==
        assert
        len
        bnz main_ternary_false@5

main_ternary_true@4:
        dig 1
        b main_ternary_merge@6

main_ternary_false@5:
        dig 1

main_ternary_merge@6:
        dig 2
        dup
        cover 2
        ==
        assert
        len
        bnz main_ternary_false@8

main_ternary_true@7:
        dig 1
        b main_ternary_merge@9

main_ternary_false@8:
        dup

main_ternary_merge@9:
        dig 1
        dup
        cover 2
        ==
        assert
        len
        bnz main_ternary_false@11

main_ternary_true@10:
        dup
        b main_ternary_merge@12

main_ternary_false@11:
        dig 1

main_ternary_merge@12:
        dig 1
        dup
        cover 2
        ==
        assert
        len
        bnz main_ternary_false@14

main_ternary_true@13:
        dup
        b main_ternary_merge@15

main_ternary_false@14:
        dup

main_ternary_merge@15:
        dig 1
        ==
        assert
        dig 1
        len
        bz main_ternary_false@17

main_ternary_true@16:
        dig 1
        b main_ternary_merge@18

main_ternary_false@17:
        dig 1

main_ternary_merge@18:
        dig 2
        dup
        cover 2
        ==
        assert
        len
        bz main_ternary_false@20

main_ternary_true@19:
        dig 1
        b main_ternary_merge@21

main_ternary_false@20:
        dup

main_ternary_merge@21:
        dig 2
        ==
        assert
        dup
        len
        bz main_ternary_false@23

main_ternary_true@22:
        dup
        b main_ternary_merge@24

main_ternary_false@23:
        dig 1

main_ternary_merge@24:
        dig 2
        ==
        assert
        dup
        len
        bz main_ternary_false@26

main_ternary_true@25:
        dup
        b main_ternary_merge@27

main_ternary_false@26:
        dup

main_ternary_merge@27:
        dig 1
        ==
        assert
        byte 0x00
        byte 0x0f
        byte 0xf0
        cover 2
        byte 0xff
        cover 3
        dig 1
        dig 1
        b&
        dig 2
        ==
        assert
        dup
        dig 3
        b|
        dig 4
        ==
        assert
        dup
        dig 4
        b^
        dig 3
        ==
        assert
        dig 1
        dig 4
        b&
        dup
        uncover 3
        ==
        assert
        dig 3
        b|
        dup
        uncover 4
        ==
        assert
        uncover 2
        b^
        ==
        assert
        int 1
        return

