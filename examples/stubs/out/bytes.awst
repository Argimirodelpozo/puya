contract BytesContract
{
  approval_program(): algopy.UInt64
  {
    base_64: algopy.Bytes = Bytes.from_base64("QmFzZSA2NCBlbmNvZGVk")
    assert(base_64 == 'Base 64 encoded')
    base_32: algopy.Bytes = Bytes.from_base32("IJQXGZJAGMZCAZLOMNXWIZLE")
    assert(base_32 == 'Base 32 encoded')
    base_16: algopy.Bytes = Bytes.from_base16("4261736520313620656E636F646564")
    assert(base_16 == 'Base 16 encoded')
    empty: algopy.Bytes = ''
    assert(reinterpret_cast<bool>(len(base_64)), comment="Non empty bytes should be Truthy")
    assert(!(reinterpret_cast<bool>(len(empty))), comment="Empty bytes should be Falsy")
    assert('a' + 'b' == 'ab')
    c: algopy.Bytes = 'c'
    c += 'd'
    assert(c == 'cd')
    abc: algopy.Bytes = 'abc'
    assert(abc[0u] == 'a')
    assert(abc[1u:] == 'bc')
    assert(abc[1u:1u] == '')
    assert(abc[:1u] == 'a')
    assert(abc[:-(len(abc), 1u)] == 'ab')
    assert(abc[-(len(abc), 2u):] == 'bc')
    assert(abc[-(len(abc), 2u):-(len(abc), 1u)] == 'b')
    assert('1234567'[1u:-(len('1234567'), 1u)] == '23456')
    true: algopy.Bytes = '1'
    false: algopy.Bytes = ''
    x: bool = !(reinterpret_cast<bool>(len(true))) ? true : true == true
    assert(x)
    assert(!(reinterpret_cast<bool>(len(true))) ? true : true == true)
    assert(!(reinterpret_cast<bool>(len(true))) ? true : false == false)
    assert(!(reinterpret_cast<bool>(len(false))) ? false : true == false)
    assert(!(reinterpret_cast<bool>(len(false))) ? false : false == false)
    assert(reinterpret_cast<bool>(len(true)) ? true : true == true)
    assert(reinterpret_cast<bool>(len(true)) ? true : false == true)
    assert(reinterpret_cast<bool>(len(false)) ? false : true == true)
    assert(reinterpret_cast<bool>(len(false)) ? false : false == false)
    (a, b, c, d): tuple[algopy.Bytes, algopy.Bytes, algopy.Bytes, algopy.Bytes] = (Bytes.from_base16("00"), Bytes.from_base16("0F"), Bytes.from_base16("F0"), Bytes.from_base16("FF"))
    assert(a & b == a)
    assert(b | c == d)
    assert(b ^ d == c)
    y: algopy.Bytes = a
    y &= d
    assert(y == a)
    y |= d
    assert(y == d)
    y ^= c
    assert(y == b)
    return 1u
  }
  
  clear_state_program(): bool
  {
    return true
  }
}