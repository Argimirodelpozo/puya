VOTE_INDEX_BYTES = 1
VOTE_COUNT_BYTES = 8
BOX_FLAT_MIN_BALANCE = 2500
BOX_BYTE_MIN_BALANCE = 400
ASSET_MIN_BALANCE = 100000
TALLY_BOX_KEY = b'V'

contract VotingContract
{
  globals {
    ['is_bootstrapped']: bool
    ['voter_count']: algopy.UInt64
    ['close_time']: algopy.UInt64
    ['nft_asset_id']: algopy.UInt64
    ['snapshot_public_key']: algopy.Bytes
    ['vote_id']: algopy.arc4.String
    ['metadata_ipfs_cid']: algopy.arc4.String
    ['start_time']: algopy.UInt64
    ['end_time']: algopy.UInt64
    ['quorum']: algopy.UInt64
    ['nft_image_url']: algopy.arc4.String
    ['option_counts']: algopy.arc4.DynamicArray
    ['total_options']: algopy.UInt64
  }
  
  constructor()
  {
    this.globals['is_bootstrapped']: bool = false
    this.globals['voter_count']: algopy.UInt64 = 0u
    this.globals['close_time']: algopy.UInt64 = 0u
    this.globals['nft_asset_id']: algopy.UInt64 = 0u
    empty_bytes: algopy.Bytes = ''
    this.globals['snapshot_public_key']: algopy.Bytes = empty_bytes
    this.globals['vote_id']: algopy.arc4.String = reinterpret_cast<algopy.arc4.String>(empty_bytes)
    this.globals['metadata_ipfs_cid']: algopy.arc4.String = reinterpret_cast<algopy.arc4.String>(empty_bytes)
    this.globals['start_time']: algopy.UInt64 = 0u
    this.globals['end_time']: algopy.UInt64 = 0u
    this.globals['quorum']: algopy.UInt64 = 0u
    this.globals['nft_image_url']: algopy.arc4.String = reinterpret_cast<algopy.arc4.String>(empty_bytes)
    this.globals['option_counts']: algopy.arc4.DynamicArray = reinterpret_cast<algopy.arc4.DynamicArray>(empty_bytes)
    this.globals['total_options']: algopy.UInt64 = 0u
  }
  
  clear_state_program(): bool
  {
    return true
  }
  
  abimethod create(vote_id: algopy.arc4.String, snapshot_public_key: algopy.Bytes, metadata_ipfs_cid: algopy.arc4.String, start_time: algopy.UInt64, end_time: algopy.UInt64, option_counts: algopy.arc4.DynamicArray, quorum: algopy.UInt64, nft_image_url: algopy.arc4.String): None
  {
    assert(start_time < end_time, comment="End time should be after start time")
    assert(end_time >= global<LatestTimestamp>(), comment="End time should be in the future")
    this.globals['vote_id']: algopy.arc4.String = vote_id
    this.globals['snapshot_public_key']: algopy.Bytes = snapshot_public_key
    this.globals['metadata_ipfs_cid']: algopy.arc4.String = metadata_ipfs_cid
    this.globals['start_time']: algopy.UInt64 = start_time
    this.globals['end_time']: algopy.UInt64 = end_time
    this.globals['quorum']: algopy.UInt64 = quorum
    this.globals['nft_image_url']: algopy.arc4.String = nft_image_url
    this::store_option_counts(option_counts)
  }
  
  abimethod get_preconditions(signature: algopy.Bytes): tuple[bool, bool, bool, algopy.UInt64]
  {
    return (this::voting_open(), this::allowed_to_vote(signature), this::already_voted(), global<LatestTimestamp>())
  }
  
  subroutine voting_open(): bool
  {
    return this.globals['is_bootstrapped'] and !(reinterpret_cast<bool>(this.globals['close_time'])) and this.globals['start_time'] <= tmp$0: algopy.UInt64 := global<LatestTimestamp>() and tmp$0 <= this.globals['end_time']
  }
  
  subroutine already_voted(): bool
  {
    (votes, exists): tuple[algopy.Bytes, bool] = box_get(reinterpret_cast<algopy.Bytes>(txn<Sender>()))
    return exists
  }
  
  subroutine store_option_counts(option_counts: algopy.arc4.DynamicArray): None
  {
    assert(reinterpret_cast<bool>(extract_uint16(option_counts, 0u)), comment="option_counts should be non-empty")
    assert(extract_uint16(option_counts, 0u) <= 112u, comment="Can't have more than 112 questions")
    this.globals['option_counts']: algopy.arc4.DynamicArray = option_counts
    total_options: algopy.UInt64 = this::calculate_total_options_count(option_counts)
    assert(total_options <= 128u, comment="Can't have more than 128 vote options")
    this.globals['total_options']: algopy.UInt64 = total_options
  }
  
  subroutine calculate_total_options_count(option_counts: algopy.arc4.DynamicArray): algopy.UInt64
  {
    total: algopy.UInt64 = 0u
    for item in option_counts {
      total += abi_decode(item, algopy.UInt64)
    }
    return total
  }
  
  subroutine allowed_to_vote(signature: algopy.Bytes): bool
  {
    algopy::ensure_budget()
    return ed25519verify(reinterpret_cast<algopy.Bytes>(txn<Sender>()), signature, this.globals['snapshot_public_key'])
  }
}

subroutine get_vote_from_box(index: algopy.UInt64): algopy.UInt64
{
  (box_data, exists): tuple[algopy.Bytes, bool] = box_get('V')
  assert(exists, comment="Box not created")
  return btoi(extract3(box_data, index, 8u))
}

subroutine increment_vote_in_box(index: algopy.UInt64): None
{
  (box_data, exists): tuple[algopy.Bytes, bool] = box_get('V')
  assert(exists, comment="Box not created")
  current_vote: algopy.UInt64 = btoi(extract3(box_data, index, 8u))
  box_replace(box_data, index, itob(current_vote + 1u))
}